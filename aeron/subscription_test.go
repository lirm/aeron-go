// Copyright 2022 Steven Stern
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package aeron

import (
	"github.com/lirm/aeron-go/aeron/atomic"
	"github.com/lirm/aeron-go/aeron/counters"
	"github.com/lirm/aeron-go/aeron/logbuffer"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"testing"
)

const (
	Channel         = "aeron:udp?endpoint=localhost:40124"
	StreamId        = int32(1002)
	RegistrationId  = int64(10)
	ChannelStatusId = int32(100)
	CorrelationId   = int64(0xC044E1A)
	SessionId       = int32(0x5E55101D)
)

func fakeFragmentHandler(buffer *atomic.Buffer, offset int32, length int32, header *logbuffer.Header) error {
	return nil
}

// If Image is non-nil, caller has to tear down the internal fake logbuffer by calling
// logbuffer.RemoveTestingLogbufferFile()
func newTestingImage() (*Image, error) {
	logbuffers, err := logbuffer.NewTestingLogbuffer()
	if err != nil {
		return nil, err
	}
	image := NewImage(SessionId, CorrelationId, logbuffers)
	arr := make([]byte, 64)
	fakeBuf := atomic.MakeBuffer(arr)
	image.subscriberPosition = NewPosition(fakeBuf, 0)
	return image, nil
}

type SubscriptionTestSuite struct {
	suite.Suite
	cc    *MockReceivingConductor
	sub   *Subscription
	image *Image
}

func (suite *SubscriptionTestSuite) SetupTest() {
	suite.cc = new(MockReceivingConductor)
	suite.sub = NewSubscription(suite.cc, Channel, RegistrationId, StreamId, ChannelStatusId)
	image, err := newTestingImage()
	suite.Require().NoError(err)
	suite.image = image
}

func (suite *SubscriptionTestSuite) TearDownTest() {
	logbuffer.RemoveTestingLogbufferFile()
}

func (suite *SubscriptionTestSuite) TestShouldEnsureTheSubscriptionIsOpenWhenPolling() {
	suite.cc.On("releaseSubscription", RegistrationId, mock.Anything)

	suite.Require().NoError(suite.sub.Close())
	suite.Assert().True(suite.sub.IsClosed())
}

func (suite *SubscriptionTestSuite) TestShouldReadNothingWhenNoImages() {
	suite.Assert().Equal(0, suite.sub.Poll(fakeFragmentHandler, 1))
}

func (suite *SubscriptionTestSuite) TestShouldReadNothingWhenThereIsNoData() {
	suite.sub.addImage(suite.image)

	suite.Assert().Equal(0, suite.sub.Poll(fakeFragmentHandler, 1))
}

// The Java unittest has a few more test cases:
// - Reader calls, which requires a fake or interfaced Image dependency injection.
// - Channel endpoint resolution calls, which requires a fake or interfaced Reader dependency injection.

func TestSubscription(t *testing.T) {
	suite.Run(t, new(SubscriptionTestSuite))
}

// Everything below is auto generated by mockery using this command:
// mockery --name=ReceivingConductor --inpackage --structname=MockReceivingConductor --print

// MockReceivingConductor is an autogenerated mock type for the ReceivingConductor type
type MockReceivingConductor struct {
	mock.Mock
}

// AddRcvDestination provides a mock function with given fields: registrationID, endpointChannel
func (_m *MockReceivingConductor) AddRcvDestination(registrationID int64, endpointChannel string) {
	_m.Called(registrationID, endpointChannel)
}

// CounterReader provides a mock function with given fields:
func (_m *MockReceivingConductor) CounterReader() *counters.Reader {
	ret := _m.Called()

	var r0 *counters.Reader
	if rf, ok := ret.Get(0).(func() *counters.Reader); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*counters.Reader)
		}
	}

	return r0
}

// RemoveRcvDestination provides a mock function with given fields: registrationID, endpointChannel
func (_m *MockReceivingConductor) RemoveRcvDestination(registrationID int64, endpointChannel string) {
	_m.Called(registrationID, endpointChannel)
}

// releaseSubscription provides a mock function with given fields: regID, images
func (_m *MockReceivingConductor) releaseSubscription(regID int64, images []Image) {
	_m.Called(regID, images)
}

type mockConstructorTestingTNewMockReceivingConductor interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockReceivingConductor creates a new instance of MockReceivingConductor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockReceivingConductor(t mockConstructorTestingTNewMockReceivingConductor) *MockReceivingConductor {
	mock := &MockReceivingConductor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
